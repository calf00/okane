<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ping Pong — シングルファイル HTML ゲーム</title>
  <meta name="description" content="軽快で遊びごたえのあるピンポン（卓球/ Pong）ゲーム。キーボード・タッチ対応、AI 対戦・2人対戦、難易度・音量設定付き。" />
  <style>
    /* ===================================================== */
    /*  Ping Pong — Single file game styles                 */
    /*  Plenty of comments and spacing so the file is easy  */
    /*  to read.                                           */
    /* ===================================================== */

    :root{
      --bg: #0f1724;           /* 深い青系の背景 */
      --panel: #0b1220;        /* UI パネル */
      --accent: #60a5fa;       /* アクセント (青) */
      --accent-2: #34d399;     /* セカンドアクセント (緑) */
      --muted: #94a3b8;        /* 弱いテキスト */
      --glass: rgba(255,255,255,0.04);
      --glass-2: rgba(255,255,255,0.02);
      --soft: 14px;
    }

    html,body{
      height:100%;
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      background: radial-gradient(1200px 800px at 10% 10%, rgba(56,189,248,0.06), transparent), radial-gradient(1000px 600px at 90% 90%, rgba(34,197,94,0.03), transparent), var(--bg);
      color: #e6eef8;
    }

    .wrap{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:20px;
      padding:24px;
      max-width:1200px;
      margin:28px auto;
      align-items:start;
    }

    /* -------------------- */
    /*  Left UI panel      */
    /* -------------------- */
    .panel{
      background: linear-gradient(180deg,var(--panel), rgba(8,12,20,0.9));
      border-radius:12px;
      padding:16px;
      box-shadow: 0 6px 24px rgba(2,6,23,0.6);
      min-height:380px;
    }

    h1{
      font-size:20px;
      margin:0 0 8px 0;
      line-height:1;
    }
    p.lead{color:var(--muted); margin:6px 0 14px 0; font-size:13px}

    .config{display:flex;flex-direction:column;gap:8px}
    .row{display:flex;gap:8px;align-items:center}
    label{font-size:13px;color:var(--muted);min-width:110px}

    .select, .range, .btn {
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.03);
      padding:8px 10px;
      border-radius:8px;
      color:inherit;
      font-size:13px;
      outline:none;
    }

    .range{width:150px}

    .btn{cursor:pointer}
    .btn.primary{background:linear-gradient(90deg,var(--accent)22%,var(--accent-2)70%);color:#051025;border:none}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04)}

    .controls{display:flex;gap:8px;margin-top:12px}

    /* -------------------- */
    /*  Right — Game area   */
    /* -------------------- */
    .stage{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:12px;
      padding:12px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), 0 6px 24px rgba(2,6,23,0.6);
    }

    .canvas-wrap{position:relative; width:100%; height:720px; display:flex; align-items:center; justify-content:center}
    canvas#game{
      border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0)); width:100%; height:100%; display:block; touch-action: none;
    }

    /* Overlay UIs */
    .hud{
      position:absolute; left:20px; top:20px; z-index:30; display:flex; gap:14px; align-items:center
    }
    .score{
      background:var(--glass); padding:10px 12px; border-radius:10px; font-weight:700; font-size:18px; min-width:72px; text-align:center;
    }
    .info{
      background:var(--glass-2); padding:8px 10px; border-radius:10px; font-size:13px; color:var(--muted)
    }

    /* Center big overlays */
    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:40; pointer-events:none
    }
    .panel-center{
      pointer-events:auto; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:18px 22px; border-radius:12px; text-align:center;
      backdrop-filter: blur(6px);
    }
    .big{font-size:22px;font-weight:700}
    .muted{color:var(--muted);font-size:14px}

    /* Small helpers */
    .kbd{display:inline-block;background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:6px;font-weight:700}

    /* Footer small text */
    .small{font-size:12px;color:var(--muted);margin-top:12px}

    /* Responsive */
    @media (max-width:1000px){
      .wrap{grid-template-columns:1fr; padding:14px}
      .canvas-wrap{height:520px}
    }

  </style>
</head>
<body>

  <div class="wrap">

    <!-- Left: Configuration & Controls -->
    <aside class="panel">
      <h1>Ping Pong — ひとりでも二人でも</h1>
      <p class="lead">キーボード／タッチ対応。AI と対戦、もしくは 2 人対戦が可能。ゲームの挙動や音は左の設定で調整できます。</p>

      <div class="config">
        <div class="row">
          <label for="mode">モード</label>
          <select id="mode" class="select">
            <option value="single">シングル (あなた vs AI)</option>
            <option value="local">ローカル2人 (キーボード/タッチ)</option>
          </select>
        </div>

        <div class="row">
          <label for="difficulty">難易度</label>
          <select id="difficulty" class="select">
            <option value="easy">やさしい</option>
            <option value="normal" selected>ふつう</option>
            <option value="hard">むずかしい</option>
            <option value="expert">エキスパート</option>
          </select>
        </div>

        <div class="row">
          <label for="ballSpeed">初期ボール速</label>
          <input id="ballSpeed" class="range" type="range" min="3" max="14" step="0.5" value="6">
          <span id="ballSpeedVal" class="muted">6</span>
        </div>

        <div class="row">
          <label for="volume">音量</label>
          <input id="volume" class="range" type="range" min="0" max="1" step="0.01" value="0.6">
          <span id="volumeVal" class="muted">60%</span>
        </div>

        <div class="row">
          <label for="victoryScore">勝利点</label>
          <select id="victoryScore" class="select">
            <option>3</option>
            <option selected>5</option>
            <option>7</option>
            <option>11</option>
          </select>
        </div>

        <div class="controls">
          <button id="startBtn" class="btn primary">ゲーム開始</button>
          <button id="pauseBtn" class="btn ghost">一時停止</button>
          <button id="resetBtn" class="btn ghost">リセット</button>
        </div>

        <div class="small">操作: プレイヤー1 W / S (上下) — プレイヤー2 ↑ / ↓。タッチ: 画面左右をドラッグで操作。</div>

        <div style="margin-top:12px;border-top:1px solid rgba(255,255,255,0.02);padding-top:12px">
          <div class="muted">ハイスコア: <span id="highscore">0</span></div>
          <div class="muted">保存設定はローカルストレージに入ります。</div>
        </div>

      </div>
    </aside>

    <!-- Right: Game Canvas -->
    <main class="stage">
      <div class="canvas-wrap">
        <canvas id="game" width="1200" height="720"></canvas>

        <!-- HUD -->
        <div class="hud">
          <div class="score" id="scoreLeft">0</div>
          <div class="score" id="scoreRight">0</div>
          <div class="info">点数: <span id="serveText">Ready</span></div>
        </div>

        <!-- Center overlay for messages -->
        <div class="overlay" id="centerOverlay">
          <div class="panel-center" id="centerPanel">
            <div class="big" id="centerTitle">Ping Pong</div>
            <div class="muted" id="centerSubtitle">Start を押してゲームを開始</div>
            <div style="margin-top:12px">
              <button id="overlayStart" class="btn primary">始める</button>
            </div>
          </div>
        </div>

      </div>
    </main>

  </div>

  <script>
  /* ========================================================
     Ping Pong Game — JavaScript
     - single-file implementation
     - features: AI, 2-player, touch support, sounds, particles
     - well-commented for learning and customization
     ======================================================== */

  (function(){
    'use strict';

    /* -------------------------
       Utilities & Constants
    ------------------------- */

    // convenience
    const $ = (sel, root=document) => root.querySelector(sel);

    const canvas = $('#game');
    const ctx = canvas.getContext('2d');

    // For crisp rendering on high-DPI screens
    function resizeCanvasToDisplaySize() {
      const ratio = window.devicePixelRatio || 1;
      const width = canvas.clientWidth * ratio | 0;
      const height = canvas.clientHeight * ratio | 0;
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
        return true;
      }
      return false;
    }

    // clamp helper
    const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));

    // Linear interpolation
    const lerp = (a,b,t) => a + (b-a) * t;

    // Random helper
    const rand = (a=0,b=1) => a + Math.random() * (b-a);

    /* -------------------------
       Game state
    ------------------------- */

    let game = null; // will store Game instance

    // get elements
    const startBtn = $('#startBtn');
    const pauseBtn = $('#pauseBtn');
    const resetBtn = $('#resetBtn');
    const overlayStart = $('#overlayStart');
    const centerOverlay = $('#centerOverlay');
    const centerTitle = $('#centerTitle');
    const centerSubtitle = $('#centerSubtitle');

    const modeSelect = $('#mode');
    const diffSelect = $('#difficulty');
    const ballSpeedRange = $('#ballSpeed');
    const ballSpeedVal = $('#ballSpeedVal');
    const volumeRange = $('#volume');
    const volumeVal = $('#volumeVal');
    const victorySelect = $('#victoryScore');
    const highscoreEl = $('#highscore');

    const scoreLeftEl = $('#scoreLeft');
    const scoreRightEl = $('#scoreRight');


    /* -------------------------
       Sound manager (WebAudio)
    ------------------------- */
    class SoundMgr {
      constructor(){
        try{
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.master = this.ctx.createGain();
          this.master.gain.value = 0.6;
          this.master.connect(this.ctx.destination);
        }catch(e){
          this.ctx = null;
        }
      }
      setVolume(v){ if(this.master) this.master.gain.value = v; }
      playBeep(freq=440,dur=0.08,type='sine',gain=0.3){
        if(!this.ctx) return;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.value = gain;
        o.connect(g); g.connect(this.master);
        o.start();
        o.stop(this.ctx.currentTime + dur);
      }
      playHit(){ this.playBeep(rand(600,900),0.05,'square',0.18); }
      playScore(){ this.playBeep(260,0.12,'sine',0.22); this.playBeep(440,0.09,'sine',0.12); }
      playWall(){ this.playBeep(160,0.08,'sawtooth',0.14); }
    }

    const sound = new SoundMgr();

    /* -------------------------
       Input (keyboard & touch)
    ------------------------- */
    class Input {
      constructor(){
        this.keys = new Set();
        this.touchState = {
          active:false, leftY:null, rightY:null
        };

        window.addEventListener('keydown', e => this.keys.add(e.key));
        window.addEventListener('keyup', e => this.keys.delete(e.key));

        // touch handling for mobile
        canvas.addEventListener('touchstart', this.onTouch.bind(this), {passive:false});
        canvas.addEventListener('touchmove', this.onTouch.bind(this), {passive:false});
        canvas.addEventListener('touchend', this.onTouchEnd.bind(this), {passive:false});
        canvas.addEventListener('touchcancel', this.onTouchEnd.bind(this), {passive:false});

        // mouse drag as alternative
        this.mouseDown = false;
        canvas.addEventListener('mousedown', (e)=>{ this.mouseDown=true; this.onMouse(e); });
        window.addEventListener('mousemove', (e)=>{ if(this.mouseDown) this.onMouse(e); });
        window.addEventListener('mouseup', ()=>{ this.mouseDown=false; });
      }

      onMouse(e){
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const w = rect.width; // clientWidth
        if(x < w/2){
          this.touchState.leftY = y / rect.height;
        }else{
          this.touchState.rightY = y / rect.height;
        }
      }

      onTouch(e){
        e.preventDefault();
        for(const t of e.touches){
          const rect = canvas.getBoundingClientRect();
          const x = t.clientX - rect.left;
          const y = t.clientY - rect.top;
          // choose left or right side
          if(x < rect.width / 2){ this.touchState.leftY = y / rect.height; }
          else { this.touchState.rightY = y / rect.height; }
        }
        this.touchState.active = true;
      }
      onTouchEnd(e){
        this.touchState.active = false; this.touchState.leftY = null; this.touchState.rightY = null;
      }

      // API for game to query
      isKey(key){ return this.keys.has(key); }
      getLeftControl(){
        // WASD or mouse/touch left
        if(this.touchState.leftY !== null){ return {type:'touch', y:this.touchState.leftY}; }
        // keyboard
        if(this.isKey('w') || this.isKey('W')) return {type:'key', dir:-1};
        if(this.isKey('s') || this.isKey('S')) return {type:'key', dir:1};
        return null;
      }
      getRightControl(){
        if(this.touchState.rightY !== null){ return {type:'touch', y:this.touchState.rightY}; }
        if(this.isKey('ArrowUp')) return {type:'key', dir:-1};
        if(this.isKey('ArrowDown')) return {type:'key', dir:1};
        return null;
      }
    }

    const input = new Input();

    /* -------------------------
       Game Entities
    ------------------------- */

    class Paddle{
      constructor(x,y,h,side){
        this.x = x; // normalized 0..1 coordinate for easier reposition on resize
        this.y = y; // center y (normalized)
        this.h = h; // normalized height
        this.w = 0.02; // normalized width
        this.speed = 1.6; // normalized per second baseline
        this.side = side; // 'left' or 'right'
        this.targetY = y;
        this.color = (side==='left')? 'rgba(96,165,250,0.95)' : 'rgba(52,211,153,0.95)';
      }
      // move towards target
      update(dt){
        const d = this.targetY - this.y;
        const step = this.speed * dt;
        if(Math.abs(d) <= step) this.y = this.targetY;
        else this.y += Math.sign(d) * step;
        // clamp center
        this.y = clamp(this.y, this.h/2, 1 - this.h/2);
      }
      // set target by control input (keyboard touch returns normalized y or dir)
      setControl(ctrl){
        if(!ctrl) return;
        if(ctrl.type === 'touch'){
          this.targetY = clamp(ctrl.y, this.h/2, 1 - this.h/2);
        }else if(ctrl.type === 'key'){
          this.targetY = clamp(this.y + ctrl.dir * 0.08, this.h/2, 1 - this.h/2);
        }
      }
      draw(ctx, toPixel){
        const {x,y,w,h} = this.toPixels(toPixel);
        ctx.fillStyle = this.color;
        roundRect(ctx, x - w/2, y - h/2, w, h, 8);
        ctx.fill();
        // subtle rim
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.lineWidth = Math.max(1, Math.round(w*0.03));
        ctx.stroke();
      }
      toPixels(toPixel){
        const W = toPixel(canvas.width, true);
        const H = toPixel(canvas.height, true);
        const px = this.x * W;
        const py = this.y * H;
        const ph = this.h * H;
        const pw = this.w * W;
        return {x:px,y:py,w:pw,h:ph};
      }
    }

    class Ball{
      constructor(x,y,r, speed){
        this.x = x; this.y = y; this.r = r; // normalized coordinates
        this.vx = 0; this.vy = 0; this.speed = speed; // normalized units per second
        this.spin = 0; // for side spin
        this.color = '#fff';
      }
      reset(x,y,speed,serveTo='left'){
        this.x = x; this.y = y; this.speed = speed;
        // random angle but biased slightly
        const ang = rand(-0.35,0.35) + (serveTo==='left'? Math.PI : 0);
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
        this.spin = 0;
      }
      update(dt){
        this.x += this.vx * dt;
        this.y += this.vy * dt;
      }
      draw(ctx, toPixel){
        const W = toPixel(canvas.width, true);
        const H = toPixel(canvas.height, true);
        const px = this.x * W;
        const py = this.y * H;
        const pr = this.r * Math.max(W,H);
        // glow
        const g = ctx.createRadialGradient(px,py,0,px,py,pr*3);
        g.addColorStop(0,'rgba(255,255,255,0.95)');
        g.addColorStop(0.2,'rgba(255,255,255,0.7)');
        g.addColorStop(1,'rgba(255,255,255,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(px,py,pr*1.6,0,Math.PI*2);
        ctx.fill();

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(px,py,pr,0,Math.PI*2);
        ctx.fill();

        // small stroke
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // small particle for visual effects
    class Particle{
      constructor(x,y,vx,vy,life,color){
        this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.life=life;this.max=life;this.color=color;
      }
      update(dt){
        this.vy += dt*0.8; // gravity-ish
        this.x += this.vx*dt; this.y += this.vy*dt;
        this.life -= dt;
      }
      draw(ctx,toPixel){
        if(this.life<=0) return;
        const W = toPixel(canvas.width,true);
        const H = toPixel(canvas.height,true);
        ctx.globalAlpha = clamp(this.life/this.max,0,1);
        const s = Math.max(1, (1 - this.life/this.max) * 6);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x*W, this.y*H, s, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    /* -------------------------
       Small helpers
    ------------------------- */
    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    // pixel converter: we store normalized coords 0..1, but canvas uses pixels
    function toPixelFactory(){
      const ratio = window.devicePixelRatio || 1;
      return function(value, raw=false){
        // when raw true, value is pixel dimension of canvas.width or height depending on arg
        // usage: toPixel(canvas.width,true) returns canvas.width
        if(raw) return value; // we already pass proper values
        return value * (canvas.width || 1200);
      }
    }

    /* -------------------------
       AI for single player
       - prediction-based with difficulty tweaking
    ------------------------- */
    class SimpleAI{
      constructor(paddle, ball, difficulty='normal'){
        this.paddle = paddle; // Paddle object (right side)
        this.ball = ball;
        this.setDifficulty(difficulty);
      }
      setDifficulty(d){
        this.difficulty = d;
        switch(d){
          case 'easy': this.reaction = 0.25; this.skill = 0.7; break;
          case 'normal': this.reaction = 0.18; this.skill = 0.85; break;
          case 'hard': this.reaction = 0.12; this.skill = 0.95; break;
          case 'expert': this.reaction = 0.06; this.skill = 1; break;
          default: this.reaction = 0.18; this.skill = 0.85;
        }
      }
      update(dt){
        // Only react when ball is moving towards AI or in neutral
        let target;
        if(this.ball.vx > 0){
          // predict future y by simple linear extrapolation with wall bounces
          let simX = this.ball.x;
          let simY = this.ball.y;
          let vx = this.ball.vx;
          let vy = this.ball.vy;
          // simulate for few steps until x reaches AI paddle
          for(let i=0;i<200;i++){
            const t = 0.02;
            simX += vx * t;
            simY += vy * t;
            // bounce on top/bottom
            if(simY - this.ball.r <= 0){ simY = this.ball.r; vy = -vy; }
            if(simY + this.ball.r >= 1){ simY = 1 - this.ball.r; vy = -vy; }
            // stop when reach AI x
            if(simX >= this.paddle.x - this.paddle.w/2 - this.ball.r) break;
          }
          target = simY;
        }else{
          // ball moving away — go to center or track slightly
          target = 0.5 + (Math.sin(performance.now()/1500) * 0.07);
        }
        // apply skill jitter
        const skillAdj = (Math.random()*2-1) * (1 - this.skill) * 0.16;
        target = clamp(target + skillAdj, this.paddle.h/2, 1 - this.paddle.h/2);
        // move paddle target with reaction speed
        const lerpFactor = clamp(1 - Math.exp(-dt/this.reaction), 0, 1);
        this.paddle.targetY = lerp(this.paddle.targetY, target, lerpFactor);
      }
    }

    /* -------------------------
       Main Game class
    ------------------------- */
    class Game{
      constructor(){
        // normalized coordinate system 0..1 in y, x
        this.left = new Paddle(0.03, 0.5, 0.18, 'left');
        this.right = new Paddle(0.97, 0.5, 0.18, 'right');
        this.ball = new Ball(0.5, 0.5, 0.01, 6);
        this.particles = [];

        this.toPixel = (v, raw) => { return raw ? v : v; };

        this.mode = 'single';
        this.difficulty = 'normal';
        this.victoryScore = 5;
        this.scoreLeft = 0; this.scoreRight = 0;
        this.isRunning = false; this.isPaused = false;
        this.lastTime = null;
        this.serveTo = 'left';

        this.ai = new SimpleAI(this.right, this.ball, this.difficulty);

        this.defaultBallSpeed = 6;
        this.ballSpeedMultiplier = 1;

        // store highscore
        this.highscore = Number(localStorage.getItem('pong_high')) || 0;
        highscoreEl.textContent = this.highscore;

        // bind resize and loop
        window.addEventListener('resize', ()=>this.onResize());
        this.onResize();
      }

      onResize(){
        // adjust normalized sizes based on aspect
        // when canvas resized we need to scale things; but since we use normalized units we just ensure drawing uses actual pixel dims
        resizeCanvasToDisplaySize();
      }

      setMode(m){ this.mode = m; }
      setDifficulty(d){ this.difficulty = d; this.ai.setDifficulty(d); }
      setVictory(v){ this.victoryScore = v; }
      setBallSpeed(v){ this.defaultBallSpeed = v; }
      setVolume(v){ sound.setVolume(v); }

      start(){
        this.isRunning = true; this.isPaused = false;
        this.scoreLeft = 0; this.scoreRight = 0;
        this.left.y = 0.5; this.right.y = 0.5;
        this.resetBall();
        this.lastTime = performance.now();
        requestAnimationFrame(this.loop.bind(this));
      }

      pause(){ this.isPaused = !this.isPaused; if(!this.isPaused) { this.lastTime = performance.now(); requestAnimationFrame(this.loop.bind(this)); } }
      reset(){ this.isRunning=false; this.isPaused=false; this.scoreLeft=0; this.scoreRight=0; this.left.y=this.right.y=0.5; this.resetBall(); }

      resetBall(){
        // ball initial speed affected by multiplier
        const s = this.defaultBallSpeed * this.ballSpeedMultiplier;
        // serve to the player who just lost (simple)
        this.ball.reset(0.5, 0.5, s, this.serveTo);
      }

      loop(now){
        if(!this.isRunning) return;
        if(this.isPaused) return;
        const dt = Math.min(0.06, (now - this.lastTime) / 1000);
        this.lastTime = now;

        this.update(dt);
        this.render();
        requestAnimationFrame(this.loop.bind(this));
      }

      update(dt){
        // update controls
        // left paddle controlled by player 1 always
        const leftCtrl = input.getLeftControl();
        this.left.setControl(leftCtrl);
        // right paddle depends on mode
        if(this.mode === 'local'){
          const rightCtrl = input.getRightControl();
          this.right.setControl(rightCtrl);
        }else{
          // AI
          this.ai.update(dt);
        }

        // update paddles
        // paddle speed slightly depends on difficulty
        const speedFactor = ({'easy':1.05,'normal':1.0,'hard':0.95,'expert':0.9}[this.difficulty] || 1.0);
        this.left.speed = 1.7 * speedFactor;
        this.right.speed = 1.7 * speedFactor;
        this.left.update(dt);
        this.right.update(dt);

        // ball physics
        // increase ball speed slowly to increase tension
        this.ball.speed += dt * 0.05; // tiny acceleration
        this.ball.update(dt);

        // top/bottom collision
        if(this.ball.y - this.ball.r <= 0){
          this.ball.y = this.ball.r; this.ball.vy = -this.ball.vy; sound.playWall();
        }
        if(this.ball.y + this.ball.r >= 1){
          this.ball.y = 1 - this.ball.r; this.ball.vy = -this.ball.vy; sound.playWall();
        }

        // paddle collisions (left)
        this.handlePaddleCollision(this.left, 'left');
        this.handlePaddleCollision(this.right, 'right');

        // check scoring (ball went off sides)
        if(this.ball.x + this.ball.r < 0){
          // right scores
          this.scoreRight += 1; this.serveTo = 'right';
          this.onScore('right');
        }
        if(this.ball.x - this.ball.r > 1){
          // left scores
          this.scoreLeft += 1; this.serveTo = 'left';
          this.onScore('left');
        }

        // update particles
        for(let i=this.particles.length-1;i>=0;i--){
          const p=this.particles[i]; p.update(dt); if(p.life<=0) this.particles.splice(i,1);
        }

        // check win
        if(this.scoreLeft >= this.victoryScore || this.scoreRight >= this.victoryScore){
          this.endMatch();
        }

        // update HUD elements
        scoreLeftEl.textContent = this.scoreLeft;
        scoreRightEl.textContent = this.scoreRight;
      }

      handlePaddleCollision(paddle, side){
        // convert to pixel or normalized accordingly
        // paddle is centered at paddle.x,paddle.y . width paddle.w, height paddle.h
        const bx = this.ball.x;
        const by = this.ball.y;
        const br = this.ball.r;
        const px = paddle.x;
        const py = paddle.y;
        const ph = paddle.h;
        const pw = paddle.w;

        // simple AABB vs circle approximation
        const closestX = clamp(bx, px - pw/2, px + pw/2);
        const closestY = clamp(by, py - ph/2, py + ph/2);
        const dx = bx - closestX;
        const dy = by - closestY;
        const dist2 = dx*dx + dy*dy;
        if(dist2 <= br*br){
          // collision!
          // reflect ball horizontally and add some vertical bias depending on where it hit the paddle
          const rel = (by - py) / (ph/2); // -1 .. 1
          const speed = Math.hypot(this.ball.vx, this.ball.vy);
          // push ball outside paddle slightly
          if(side==='left') this.ball.x = px + pw/2 + br + 0.001;
          else this.ball.x = px - pw/2 - br - 0.001;

          // new angle based on rel and incoming direction
          const angle = rel * Math.PI/3; // up to 60deg
          const dir = (side==='left') ? 0 : Math.PI; // base direction
          // flip X direction
          const sign = (side==='left') ? 1 : -1;
          const newVx = Math.cos(angle) * speed * sign;
          const newVy = Math.sin(angle) * speed;

          // add a bit of paddle motion to the ball
          const paddleMotion = (paddle.targetY - paddle.y) * 6.0;
          this.ball.vx = newVx;
          this.ball.vy = newVy + paddleMotion * 0.9;

          // tiny speed increase on hit
          this.ball.vx *= 1.02;
          this.ball.vy *= 1.02;

          // spawn particles
          this.spawnHitParticles(this.ball.x, this.ball.y, rel);

          sound.playHit();
        }
      }

      spawnHitParticles(x,y,rel){
        const n = 12;
        for(let i=0;i<n;i++){
          const ang = rand(0,Math.PI*2);
          const s = rand(0.8,2.4);
          const vx = Math.cos(ang) * s * 0.3;
          const vy = Math.sin(ang) * s * 0.3;
          const color = (rel>0) ? 'rgba(52,211,153,0.9)' : 'rgba(96,165,250,0.9)';
          this.particles.push(new Particle(x,y,vx,vy,rand(0.3,0.7),color));
        }
      }

      onScore(side){
        sound.playScore();
        // particles big
        for(let i=0;i<40;i++){
          const ang = rand(0,Math.PI*2);
          const s = rand(0,8);
          const vx = Math.cos(ang) * s * 0.04;
          const vy = Math.sin(ang) * s * 0.04;
          const color = (side==='left') ? 'rgba(96,165,250,0.9)' : 'rgba(52,211,153,0.9)';
          this.particles.push(new Particle((side==='left')?0.2:0.8, 0.5, vx, vy, rand(0.5,1.2), color));
        }
        // reset ball to center and serve to loser
        this.resetBall();
      }

      endMatch(){
        this.isRunning = false;
        // show overlay
        const winner = (this.scoreLeft > this.scoreRight) ? '左 (Player 1)' : '右 (Player 2 / AI)';
        centerTitle.textContent = '試合終了';
        centerSubtitle.textContent = `勝者: ${winner} — もう一度プレイするには始めるを押してください`;
        centerOverlay.style.display = 'flex';

        // store highscore
        const mx = Math.max(this.scoreLeft, this.scoreRight);
        if(mx > this.highscore){ this.highscore = mx; localStorage.setItem('pong_high', String(this.highscore)); highscoreEl.textContent = this.highscore; }

        // update serve text
        $('#serveText').textContent = 'Finished';
        sound.playScore();
      }

      render(){
        const W = canvas.width;
        const H = canvas.height;

        // clear
        ctx.clearRect(0,0,W,H);

        // background subtle grid
        ctx.save();
        ctx.globalAlpha = 0.06;
        ctx.fillStyle = '#ffffff';
        const step = Math.round(H * 0.05);
        for(let y=step;y<H;y+=step){ ctx.fillRect(0,y, W, 1); }
        ctx.restore();

        // center line
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.setLineDash([10,14]); ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(W/2, 30); ctx.lineTo(W/2, H-30); ctx.stroke();
        ctx.restore();

        // draw paddles and ball
        this.left.draw(ctx, (v,raw)=> raw ? v : W);
        this.right.draw(ctx, (v,raw)=> raw ? v : W);
        this.ball.draw(ctx, (v,raw)=> raw ? v : W);

        // draw particles
        for(const p of this.particles) p.draw(ctx, (v,raw)=> raw ? v : W);

        // top-left info
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(12,12,220,36);
        ctx.fillStyle = '#e6eef8';
        ctx.font = `${14 * (window.devicePixelRatio||1)}px sans-serif`;
        ctx.fillText(`Mode: ${this.mode} — Difficulty: ${this.difficulty}`, 22, 36);
        ctx.restore();

        // small shadow around canvas
        // (we keep this purely cosmetic and light)
      }

    }

    /* -------------------------
       Wiring UI with game
    ------------------------- */

    function initUI(){
      // create game instance
      game = new Game();

      // overlay start
      overlayStart.addEventListener('click', ()=>{
        centerOverlay.style.display = 'none';
        startGameFromUI();
      });

      startBtn.addEventListener('click', ()=>{
        centerOverlay.style.display = 'none';
        startGameFromUI();
      });
      pauseBtn.addEventListener('click', ()=>{
        if(!game || !game.isRunning) return;
        game.pause();
        pauseBtn.textContent = game.isPaused ? '再開' : '一時停止';
      });
      resetBtn.addEventListener('click', ()=>{
        if(!game) return;
        game.reset();
        centerTitle.textContent = 'Ping Pong';
        centerSubtitle.textContent = 'Start を押してゲームを開始';
        centerOverlay.style.display = 'flex';
      });

      modeSelect.addEventListener('change', e=>{ game.setMode(e.target.value); });
      diffSelect.addEventListener('change', e=>{ game.setDifficulty(e.target.value); });
      victorySelect.addEventListener('change', e=>{ game.setVictory(Number(e.target.value)); });

      ballSpeedRange.addEventListener('input', e=>{ ballSpeedVal.textContent = e.target.value; game.setBallSpeed(Number(e.target.value)); });
      volumeRange.addEventListener('input', e=>{ volumeVal.textContent = Math.round(Number(e.target.value) * 100) + '%'; game.setVolume(Number(e.target.value)); });

      // keyboard shortcuts
      window.addEventListener('keydown', (e)=>{
        if(e.key === ' '){ // space for pause
          if(game && game.isRunning){ game.pause(); pauseBtn.textContent = game.isPaused ? '再開' : '一時停止'; }
        }
      });

      // initial visibility of overlay
      centerOverlay.style.display = 'flex';

      // expose some touch hints for mobile
      canvas.addEventListener('touchstart', ()=>{
        // unlock AudioContext on iOS
        if(sound && sound.ctx && sound.ctx.state === 'suspended') sound.ctx.resume();
      }, {passive:true});

      // show serve text
      $('#serveText').textContent = 'Ready';

      // make sure UI reflects defaults
      game.setMode(modeSelect.value);
      game.setDifficulty(diffSelect.value);
      game.setVictory(Number(victorySelect.value));
      game.setBallSpeed(Number(ballSpeedRange.value));
      game.setVolume(Number(volumeRange.value));

      // Show highscore
      highscoreEl.textContent = game.highscore;
    }

    function startGameFromUI(){
      if(!game) return;
      // ensure audio resumed
      if(sound && sound.ctx && sound.ctx.state === 'suspended') sound.ctx.resume();

      game.setMode(modeSelect.value);
      game.setDifficulty(diffSelect.value);
      game.setVictory(Number(victorySelect.value));
      game.setBallSpeed(Number(ballSpeedRange.value));
      game.setVolume(Number(volumeRange.value));
      game.isRunning = true;
      game.isPaused = false;
      game.scoreLeft = 0; game.scoreRight = 0;
      $('#serveText').textContent = 'Playing';

      // initial serve: random
      game.serveTo = Math.random() > 0.5 ? 'left' : 'right';
      game.resetBall();
      game.lastTime = performance.now();
      requestAnimationFrame(game.loop.bind(game));
    }

    // initial setup
    initUI();

    // small loop to keep overlay reactive even if game not running
    (function overlayTicker(){
      // tiny animation for center overlay if visible
      const t = performance.now()/1000;
      if(centerOverlay.style.display === 'flex'){
        centerPanel.style.transform = `translateY(${Math.sin(t*1.5)*3}px)`;
      }
      requestAnimationFrame(overlayTicker);
    })();

  })();

  </script>
</body>
</html>
